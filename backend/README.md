# Vue Shop Backend

Spring Boot REST API бэкенд для приложения Vue Shop.

## Требования

- Java 17 или выше
- Maven 3.6+
- PostgreSQL 12+ (или Docker для запуска PostgreSQL в контейнере)

## Архитектура

Организация кода backend-части следует принципам многослойной архитектуры с четким разделением ответственности:

- `model/` - содержит JPA-сущности (`Item`, `Favorite`), отражающие структуру данных в базе данных. Эти классы определяют схему таблиц и обеспечивают объектно-реляционное отображение.

- `repository/` - реализует паттерн Repository для абстрагирования доступа к данным. Слой использует Spring Data JPA и инкапсулирует всю логику работы с базой данных, предоставляя стандартные CRUD-операции.

- `service/` - содержит бизнес-логику приложения. Этот слой обрабатывает запросы от контроллеров, применяет бизнес-правила (фильтрация, сортировка) и координирует взаимодействие с репозиториями.

- `controller/` - обрабатывает HTTP-запросы, валидирует входные данные и преобразует их в формат, понятный сервисному слою. Контроллеры возвращают данные в формате JSON и обеспечивают REST API для фронтенда.

- `config/` - содержит конфигурационные классы Spring (`CorsConfig` для настройки CORS, `DataInitializer` для инициализации начальных данных в базе).

Такое разделение обеспечивает слабую связанность компонентов и упрощает тестирование, так как каждый слой может быть протестирован изолированно. Изменения в одном слое не требуют модификации других слоев.

## Бизнес-логика и алгоритмы

Бизнес-логика системы "Vue Shop" реализована в слое сервисов и контроллеров, который инкапсулирует всю работу с данными. В данном разделе описываются ключевые алгоритмы работы с данными, включая процессы получения товаров с фильтрацией и сортировкой, управления избранным и инициализации данных. Алгоритмы построены с учетом эффективности и надежности операций с базой данных.

### Алгоритм получения товаров с фильтрацией и сортировкой

1. НАЧАЛО алгоритма GetItems

2. Получить входные параметры: `title` (строка поиска), `sortBy` (тип сортировки)

3. ЕСЛИ `title` не пустой И начинается с `*` И заканчивается на `*`:

   - УДАЛИТЬ первый и последний символы из `title`
   - Сохранить результат в `searchTitle`

4. ЕСЛИ `searchTitle` пустой ИЛИ равен null:

   - ВЫПОЛНИТЬ запрос к БД: `SELECT * FROM items` (через `itemRepository.findAll()`)
   - Сохранить результат в список `items`

5. ИНАЧЕ:

   - ВЫПОЛНИТЬ запрос к БД: `SELECT * FROM items` (через `itemRepository.findAll()`)
   - ПРИМЕНИТЬ фильтрацию: оставить только товары, где `title` содержит `searchTitle` (без учета регистра)
   - Сохранить отфильтрованный результат в список `items`

6. ПРИМЕНИТЬ сортировку к списку `items`:

   - ЕСЛИ `sortBy` равен "name": отсортировать по полю `title` по возрастанию
   - ЕСЛИ `sortBy` равен "price": отсортировать по полю `price` по возрастанию
   - ЕСЛИ `sortBy` равен "-price": отсортировать по полю `price` по убыванию
   - ИНАЧЕ: отсортировать по полю `title` по возрастанию (по умолчанию)

7. ВЕРНУТЬ отсортированный список `items`

8. КОНЕЦ алгоритма

**Особенности реализации:**

- Использование Stream API для эффективной фильтрации данных в памяти
- Поддержка поиска с подстановочными знаками через обработку формата `*search*`
- Регистронезависимый поиск через преобразование в нижний регистр
- Гибкая система сортировки с поддержкой нескольких критериев

### Алгоритм добавления товара в избранное

1. НАЧАЛО алгоритма AddFavorite

2. Получить входные данные: структура запроса с полем `parentId` (ID товара)

3. ВАЛИДАЦИЯ: ЕСЛИ `parentId` равен null ИЛИ отсутствует:

   - ВЕРНУТЬ HTTP статус 400 (Bad Request)

4. СОЗДАТЬ новый объект `Favorite` с параметром `parentId`

5. ВЫПОЛНИТЬ SQL-запрос INSERT в таблицу `favorites`:

   - `INSERT INTO favorites (parent_id) VALUES (parentId)`
   - (через `favoriteRepository.save(favorite)`)

6. ЕСЛИ операция успешна:

   - ВЕРНУТЬ HTTP статус 201 (Created) с сохраненным объектом `Favorite`
   - ИНАЧЕ ВЕРНУТЬ ошибку базы данных

7. КОНЕЦ алгоритма

**Особенности реализации:**

- Валидация входных данных на уровне контроллера
- Автоматическая генерация ID через JPA `@GeneratedValue`
- Использование транзакционной семантики Spring для обеспечения целостности данных

### Алгоритм удаления товара из избранного

1. НАЧАЛО алгоритма DeleteFavorite

2. Получить входной параметр: `id` (ID записи избранного)

3. ВЫПОЛНИТЬ проверку существования записи:

   - `SELECT EXISTS(SELECT 1 FROM favorites WHERE id = id)`
   - (через `favoriteRepository.existsById(id)`)

4. ЕСЛИ запись не найдена:

   - ВЕРНУТЬ HTTP статус 404 (Not Found)

5. ИНАЧЕ:

   - ВЫПОЛНИТЬ SQL-запрос DELETE:
     - `DELETE FROM favorites WHERE id = id`
     - (через `favoriteRepository.deleteById(id)`)

6. ВЕРНУТЬ HTTP статус 204 (No Content)

7. КОНЕЦ алгоритма

**Особенности реализации:**

- Проверка существования записи перед удалением для предотвращения ошибок
- Использование идемпотентных операций (безопасное повторное выполнение)
- Корректная обработка отсутствующих записей

### Алгоритм получения всех избранных товаров

1. НАЧАЛО алгоритма GetAllFavorites

2. ВЫПОЛНИТЬ SQL-запрос: `SELECT * FROM favorites`

   - (через `favoriteRepository.findAll()`)

3. СОЗДАТЬ список избранных товаров

4. ДЛЯ каждой строки результата:

   - СОЗДАТЬ объект `Favorite` с полями `id` и `parentId`
   - Добавить объект в список

5. ВЕРНУТЬ список избранных товаров с HTTP статусом 200 (OK)

6. КОНЕЦ алгоритма

**Особенности реализации:**

- Простое получение всех записей без дополнительной фильтрации
- Эффективное использование Spring Data JPA для автоматической маппинга результатов

### Алгоритм инициализации начальных данных

1. НАЧАЛО алгоритма InitializeData

2. ВЫПОЛНИТЬ проверку: подсчитать количество записей в таблице `items`

   - `SELECT COUNT(*) FROM items`
   - (через `itemRepository.count()`)

3. ЕСЛИ количество записей равно 0:

   - ВЫПОЛНИТЬ последовательность INSERT-запросов для добавления 10 товаров:
     - `INSERT INTO items (title, image_url, price) VALUES (...)`
     - (через `itemRepository.save(new Item(...))` для каждого товара)

4. ИНАЧЕ:

   - Пропустить инициализацию (данные уже существуют)

5. КОНЕЦ алгоритма

**Особенности реализации:**

- Автоматический запуск при старте приложения через `CommandLineRunner`
- Защита от повторной инициализации через проверку количества записей
- Использование транзакций для атомарности операций вставки

### Алгоритм объединения данных товаров и избранного (Frontend)

1. НАЧАЛО алгоритма MergeItemsWithFavorites

2. ВЫПОЛНИТЬ параллельные HTTP-запросы:

   - `GET /items?sortBy=...&title=...` → получить список товаров
   - `GET /favorites` → получить список избранного

3. ДЛЯ каждого товара из списка `items`:

   - ИНИЦИАЛИЗИРОВАТЬ поля: `isFavorite = false`, `favoriteId = null`, `isAdded = false`
   - НАЙТИ в списке `favorites` запись, где `parentId` равен `item.id`
   - ЕСЛИ запись найдена:
     - УСТАНОВИТЬ `isFavorite = true`
     - УСТАНОВИТЬ `favoriteId = favorite.id`

4. ВЕРНУТЬ обогащенный список товаров с информацией об избранном

5. КОНЕЦ алгоритма

**Особенности реализации:**

- Клиентская обработка данных для объединения информации из разных источников
- Реактивное обновление UI при изменении состояния избранного
- Оптимизация через параллельные запросы для уменьшения времени загрузки

### Алгоритм управления корзиной (Frontend)

1. НАЧАЛО алгоритма ManageCart

2. **Добавление товара в корзину:**

   - ЕСЛИ товар еще не добавлен (`isAdded = false`):
     - ДОБАВИТЬ товар в массив `cart`
     - УСТАНОВИТЬ `item.isAdded = true`

3. **Удаление товара из корзины:**

   - ЕСЛИ товар добавлен (`isAdded = true`):
     - НАЙТИ индекс товара в массиве `cart`
     - УДАЛИТЬ товар из массива `cart` по индексу
     - УСТАНОВИТЬ `item.isAdded = false`

4. **Вычисление общей стоимости:**

   - ИНИЦИАЛИЗИРОВАТЬ переменную `totalPrice = 0`
   - ДЛЯ каждого товара в массиве `cart`:
     - ДОБАВИТЬ `item.price` к `totalPrice`
   - ВЕРНУТЬ `totalPrice`

5. КОНЕЦ алгоритма

**Особенности реализации:**

- Клиентское хранение состояния корзины (не сохраняется на сервере)
- Реактивное вычисление общей стоимости через Vue `computed`
- Синхронизация состояния между компонентами через Vue `provide/inject`

### Принципы обработки ошибок

Все алгоритмы включают обработку следующих сценариев:

- **Отсутствие данных:** возврат соответствующих HTTP статусов (404 для не найденных ресурсов, 400 для невалидных запросов)
- **Ошибки базы данных:** автоматическая обработка через Spring Data JPA с корректным закрытием соединений
- **Валидация данных:** проверка обязательных полей перед выполнением операций на уровне контроллеров
- **Сетевые ошибки:** обработка на фронтенде через try-catch блоки с логированием в консоль

**Принципы обработки:**

- Использование паттерна "early return" для быстрого выхода при ошибках валидации
- Гарантированное освобождение ресурсов через Spring Framework (автоматическое управление транзакциями)
- Единообразная обработка исключений через Spring Exception Handlers
- Graceful degradation на фронтенде при недоступности API

### Заключение

Представленные алгоритмы демонстрируют эффективную реализацию бизнес-логики системы "Vue Shop". Ключевыми особенностями являются:

- Использование Spring Data JPA для минимизации boilerplate-кода при работе с БД
- Эффективная фильтрация и сортировка данных на уровне приложения
- Разделение ответственности между клиентом и сервером (корзина на клиенте, избранное на сервере)
- Надежная обработка ошибок и исключительных ситуаций
- Модульная структура, позволяющая легко расширять функциональность

Алгоритмы обеспечивают выполнение всех основных сценариев использования системы, высокую производительность и надежность работы с данными.

## Запуск через Docker Compose (весь стек)

В корне репозитория доступен `docker-compose.yml`, который поднимает PostgreSQL, Spring Boot бэкенд и Vue фронтенд:

```bash
docker compose up --build
```

Эта команда подходит для локальной разработки или демо. Остальные разделы описывают ручной запуск только бэкенда.

## Настройка базы данных

### Вариант 1: Использование Docker (Рекомендуется)

1. Запустите PostgreSQL с помощью Docker Compose:

   ```bash
   cd backend
   docker-compose up -d
   ```

   Это запустит PostgreSQL на порту 5432 с настройками:

   - База данных: `vueshop`
   - Пользователь: `postgres`
   - Пароль: `postgres`

### Вариант 2: Локальная установка PostgreSQL

1. Установите PostgreSQL на вашу систему
2. Создайте базу данных:
   ```sql
   CREATE DATABASE vueshop;
   ```
3. Обновите `application.properties` с вашими учетными данными PostgreSQL:
   ```properties
   spring.datasource.url=jdbc:postgresql://localhost:5432/vueshop
   spring.datasource.username=your_username
   spring.datasource.password=your_password
   ```

## Запуск приложения

1. Перейдите в директорию backend:

   ```bash
   cd backend
   ```

2. Убедитесь, что PostgreSQL запущен (см. Настройка базы данных выше)

3. Соберите проект:

   ```bash
   mvn clean install
   ```

4. Запустите приложение:
   ```bash
   mvn spring-boot:run
   ```

API будет доступен по адресу `http://localhost:8080`

**Примечание:** Примеры данных (10 велосипедов) будут автоматически инициализированы при первом запуске, если база данных пуста.

## API Endpoints

### Товары

- `GET /items` - Получить все товары
  - Параметры запроса:
    - `title` (необязательный): Фильтр поиска (поддерживает формат с подстановочными знаками `*search*`)
    - `sortBy` (необязательный, по умолчанию: "name"): Порядок сортировки - "name", "price", или "-price"

### Избранное

- `GET /favorites` - Получить все избранное
- `POST /favorites` - Добавить в избранное
  - Тело запроса: `{ "parentId": <item_id> }`
- `DELETE /favorites/{id}` - Удалить из избранного

## База данных

Приложение использует базу данных PostgreSQL. Таблицы автоматически создаются при первом запуске.

### Подключение к PostgreSQL

Вы можете подключиться к базе данных, используя любой PostgreSQL клиент:

**Использование psql (командная строка):**

```bash
psql -h localhost -U postgres -d vueshop
# Пароль: postgres
```

**Использование pgAdmin или DBeaver:**

- Хост: `localhost`
- Порт: `5432`
- База данных: `vueshop`
- Пользователь: `postgres`
- Пароль: `postgres`

### Изменение данных

1. **Через код:** Отредактируйте `DataInitializer.java` для изменения начальных данных
2. **Через SQL клиент:** Подключитесь к PostgreSQL и выполните SQL запросы
3. **Через API:** Используйте REST endpoints для изменения избранного

### Полезные SQL запросы

```sql
-- Просмотр всех товаров
SELECT * FROM items;

-- Просмотр всего избранного
SELECT * FROM favorites;

-- Добавить новый товар
INSERT INTO items (title, image_url, price)
VALUES ('Новый велосипед', '/velo/velo1.jpg', 30000);

-- Обновить товар
UPDATE items SET price = 28000 WHERE id = 1;

-- Удалить товар
DELETE FROM items WHERE id = 1;
```

Для более подробной информации см. [DATABASE.md](DATABASE.md)
